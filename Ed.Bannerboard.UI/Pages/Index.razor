@page "/"

@using System.Net.WebSockets
@using System.Threading
@using System.IO
@using System.Runtime.Serialization.Formatters.Binary;

@implements IDisposable

@if (webSocket.State == WebSocketState.Connecting)
{
    <div class="container-fluid mt-4">
        <p>Connnecting to your Bannerlord campaign...</p>
    </div>
}

@if (webSocket.State == WebSocketState.Open)
{
    <div class="container-fluid">
        <div class="row">
            <div class="col-sm col-xs-12 mt-4">
                <KingdomStrength @ref="kingdomStrength" />
            </div>
            <div class="col-sm col-xs-12 mt-4">
                <KingdomLords @ref="kingdomLords" />
            </div>
        </div>
        <div class="row">
            <div class="col-sm col-xs-12 mt-4">
                <KingdomWars @ref="kingdomWars" />
            </div>
            <div class="col-sm col-xs-12 mt-4">
                <Stats @ref="stats" />
            </div>
        </div>
    </div>
}

@if (webSocket.State == WebSocketState.Aborted
   || webSocket.State == WebSocketState.Closed
   || webSocket.State == WebSocketState.CloseReceived
   || webSocket.State == WebSocketState.CloseSent)
{
    <div class="container-fluid mt-4">
        <p>Could not establish a connection to the server. Refresh the page once you've loaded a campaign.</p>
        <p>Download this Mount & Blade II: Bannerlord mod from <a href="https://www.nexusmods.com/mountandblade2bannerlord/mods/3386">https://www.nexusmods.com/mountandblade2bannerlord/mods/3386</a>.</p>
        <p>See the source code at <a href="https://github.com/edgarssults/Bannerboard">https://github.com/edgarssults/Bannerboard</a>.</p>
    </div>
}

@code {
    private CancellationTokenSource disposalTokenSource = new CancellationTokenSource();
    private ClientWebSocket webSocket = new ClientWebSocket();

    // TODO: Dynamically render and update the widgets from a list when Blazor supports it
    private KingdomStrength kingdomStrength;
    private KingdomLords kingdomLords;
    private KingdomWars kingdomWars;
    private Stats stats;

    protected override async Task OnInitializedAsync()
    {
        // TODO: Inform which widgets and versions the dashboard supports
        // TODO: Support multiple client connections per server
        try
        {
            await webSocket.ConnectAsync(new Uri("ws://localhost:2020"), disposalTokenSource.Token); // TODO: Change the port or use an URL?
            _ = ReceiveLoop();
        }
        catch
        {
            // TODO: Retry failed connections
        }
    }

    async Task ReceiveLoop()
    {
        var buffer = new ArraySegment<byte>(new byte[2048]);
        object receivedObject;
        var statsModel = new StatsModel();

        do
        {
            WebSocketReceiveResult result;
            using (var stream = new MemoryStream())
            {
                do
                {
                    // Wait for a message from the server
                    // Read it into the stream via the buffer when one is received
                    result = await webSocket.ReceiveAsync(buffer, disposalTokenSource.Token);
                    stream.Write(buffer.Array, buffer.Offset, result.Count);
                } while (!result.EndOfMessage);

                if (result.MessageType == WebSocketMessageType.Close)
                {
                    webSocket.Abort();
                    base.StateHasChanged();
                    break;
                }

                // Deserialize the stream into an object
                // Only expecting messages with binary data
                stream.Seek(0, SeekOrigin.Begin);
                var formatter = new BinaryFormatter();
                receivedObject = formatter.Deserialize(stream);

                statsModel.LastMessageBytes = stream.Length;
                statsModel.ReceivedMessageCount++;
            }

            // Send model to widgets
            // TODO: Send to the widget that cares, need an array and dynamic rendering to do this

            await stats.Update(statsModel);

            if (kingdomStrength.CanUpdate(receivedObject))
            {
                await kingdomStrength.Update(receivedObject);
                continue;
            }

            if (kingdomLords.CanUpdate(receivedObject))
            {
                await kingdomLords.Update(receivedObject);
                continue;
            }

            if (kingdomWars.CanUpdate(receivedObject))
            {
                await kingdomWars.Update(receivedObject);
                continue;
            }
        } while (!disposalTokenSource.IsCancellationRequested);
    }

    public void Dispose()
    {
        disposalTokenSource.Cancel();
        _ = webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Bannerboard client stopped", CancellationToken.None);
    }
}
