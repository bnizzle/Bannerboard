@page "/"
@using System.Net.WebSockets
@using System.Text
@using System.Threading
@using System.IO
@using System.Runtime.Serialization.Formatters.Binary;
@implements IDisposable

@if (webSocket.State == WebSocketState.Open)
{
    <div class="container-fluid">
        <div class="row">
            <div class="col-sm col-xs-12 mt-4">
                <KingdomStrength @ref="kingdomStrength" />
            </div>
            <div class="col-sm col-xs-12 mt-4">
                <KingdomLords @ref="kingdomLords" />
            </div>
        </div>
        <div class="row">
            <div class="col-sm col-xs-12 mt-4">
                <KingdomWars @ref="kingdomWars" />
            </div>
            <div class="col-sm col-xs-12 mt-4">
                <Stats @ref="stats" />
            </div>
        </div>
    </div>
}
else
{
    <h3>Connection: @stateMessage</h3>
}

@code {
    private CancellationTokenSource disposalTokenSource = new CancellationTokenSource();
    private ClientWebSocket webSocket = new ClientWebSocket();
    private string stateMessage;

    // TODO: Dynamically render and update the widgets from a list when Blazor supports it
    private KingdomStrength kingdomStrength;
    private KingdomLords kingdomLords;
    private KingdomWars kingdomWars;
    private Stats stats;

    /// <summary>
    /// Component initialization logic.
    /// </summary>
    protected override async Task OnInitializedAsync()
    {
        stateMessage = webSocket.State.ToString();

        // TODO: Inform which widgets and versions the dashboard supports
        try
        {
            await webSocket.ConnectAsync(new Uri("ws://localhost:2020"), disposalTokenSource.Token); // TODO: Change the port or use an URL?
            stateMessage = webSocket.State.ToString();
            _ = ReceiveLoop();
        }
        catch
        {
            // TODO: Retry timer
            stateMessage = "Failed. Have you loaded a game?";
        }
    }

    /// <summary>
    /// WebSocket message reception loop.
    /// </summary>
    async Task ReceiveLoop()
    {
        var buffer = new ArraySegment<byte>(new byte[2048]);
        object receivedObject;
        var statsModel = new StatsModel();

        do
        {
            WebSocketReceiveResult result;
            using (var stream = new MemoryStream())
            {
                do
                {
                    // Wait for a message from the server
                    // Read it into the stream via the buffer when one is received
                    result = await webSocket.ReceiveAsync(buffer, disposalTokenSource.Token);
                    stream.Write(buffer.Array, buffer.Offset, result.Count);
                } while (!result.EndOfMessage);

                if (result.MessageType == WebSocketMessageType.Close)
                {
                    // TODO: Show in UI that server has stopped
                    break;
                }

                // Deserialize the stream into an object
                // Only expecting messages with binary data
                stream.Seek(0, SeekOrigin.Begin);
                var formatter = new BinaryFormatter();
                receivedObject = formatter.Deserialize(stream);

                statsModel.LastMessageBytes = stream.Length;
                statsModel.ReceivedMessageCount++;
            }

            // Send model to widgets
            // TODO: Send to the widget that cares, need an array and dynamic rendering to do this

            await stats.Update(statsModel);

            if (kingdomStrength.CanUpdate(receivedObject))
            {
                await kingdomStrength.Update(receivedObject);
                continue;
            }

            if (kingdomLords.CanUpdate(receivedObject))
            {
                await kingdomLords.Update(receivedObject);
                continue;
            }

            if (kingdomWars.CanUpdate(receivedObject))
            {
                await kingdomWars.Update(receivedObject);
                continue;
            }
        } while (!disposalTokenSource.IsCancellationRequested);
    }

    /// <summary>
    /// Disposal logic.
    /// </summary>
    public void Dispose()
    {
        disposalTokenSource.Cancel();
        _ = webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Bannerboard client stopped", CancellationToken.None);
    }
}
